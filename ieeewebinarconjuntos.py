# -*- coding: utf-8 -*-
"""IEEEWebinarConjuntos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DDPTRluKGKeAjcL7Ri6dsWlXqKEt_ird

Resolución del problema **SUMA DE SUBCONJUTOS** utilizando deap
https://deap.readthedocs.io/en/master/

En primer lugar, debemos intalar la librería:
"""

!pip install deap

"""**Importamos las liberías necesarias:**
1. random: números pseudoaleatorios
2. numpy: arrays
3. maplotlib.pyplot: visualizar los resultados
4. deap.base: incluye las clases base de deap. En concreto dos son importantes en nuestro ejemplo, base.Fitness y base.Toolbox.
5. deap.creator: permite crear clases nuevas.
6. deap.tools: herramientas para implementar los algoritmos genéticos: operadores genéticos (selección, cruce y mutación), hallofFame, estadística, registro de evolución, etc.
7. deap.alorihtms: incluye implementaciones completas de algoritmos genéticos, nosotros vamos a utilizar eaSimple.
"""

import random
import numpy as np
import matplotlib.pyplot as plt    
from deap import base
from deap import creator
from deap import tools
from deap import algorithms

"""**Datos del problema**
* LIMITE_INF y LIMITE_SUP: Límites de los valores del conjunto.
* TAM_CONJUNTO: Número de elementos del conjunto.
* SUMA_OBJETIVO: Suma objetivo del subconjunto seleccionado. 
* CONJUNTO: Array que contiene el conjunto de valores.
"""

random.seed(42) # ajustamos aquí la semilla para que todos tengamos los mismos valores
LIMITE_INF, LIMITE_SUP = 0, 30
TAM_CONJUNTO = 30 
SUMA_OBJETIVO = 333
CONJUNTO = np.array(random.sample(range(LIMITE_INF, LIMITE_SUP), TAM_CONJUNTO))
print(CONJUNTO)
print("Valor máximo que puede tener SUMA_OBJETIVO", sum(CONJUNTO))

"""Creamos la clase que define el fitness de los individuos **FitnessMulti**. Este paso en la mayoría de los problemas será muy parecido. Siempre tendremos que heredar de base.Fitness. El atributo **weights** nos dice el número de objetivos de nuestro problema y el tipo (-1.0 para minimizar y 1.0 para maximizar). En este caso es un problema de dos objetivos ambos de  **minimización**."""

creator.create("FitnessMulti", base.Fitness, weights=(-1.0, -1.0))

"""Ahora creamos la "plantilla" del individuo, el cromosoma. El individuo será una lista (hereda los métodos de la lista), pero tiene el atributo FitnessMulti creado en la línea anterior. Representar los individuos como lista nos servirá en una gran cantidad de casos (lista de variables del problema)."""

creator.create("Individual", list, fitness=creator.FitnessMulti)

"""El objeto toolbox funciona como una "caja de herramientas" donde **debemos registrar operaciones que nos hacen falta en el algoritmo genético**. Cosas que debemos registrar:
1. Funciones para crear tanto individuos aleatorios como la población inicial.
2. Operadores genéticos (selección, cruce y mutación).
3. La función de evaluación.
"""

toolbox = base.Toolbox()

"""Comenzamos registrando las funciones que nos permiten generar individuos aleatorios y la población incial. Empezamos por muestra aleatorias de individuos (cromosoma). **No es el individuo completo ya que no tiene el  atributo fitness**.
Utilizamos la función random.randint para generar números binarios https://docs.python.org/3/library/random.html
"""

def crea_individuo(size):
    return [random.randint(0, 1) for i in range(size)]
toolbox.register("attr", crea_individuo, TAM_CONJUNTO)

"""Podemos ver la muestra que se crea:"""

print(toolbox.attr())

"""Generamos individuos aleatorios y población inicial"""

toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.attr)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

"""Vamos a ver cómo funcionan con un par de ejemplos:"""

ind = toolbox. individual() # creamos un individuo aleatorio
print(ind)
print(ind.fitness.values) # en fitness.values se guardará el fitness

"""**Definimos la función objetivo:**
1.   Seleccionamos del conjunto original aquellas posiciones en las que individuo tiene un 1.
2.   Sumamos los elementos seleccionados.
3.   Calculamos la diferencia.
4.   Calculamos el número de elementos.
5.   Comprobamos las restricciones. Si no se cumplen, pena de muerte.
6.   Devolvemos el fitness para cada objetivo.

**IMPORTANTE:** Siempre debemos devolver una tupla!! 

**IMPORTANTE:** Si aplicamos la pena de muerte tiene que ser a los dos objetivos!!
"""

def funcion_objetivo(individuo, suma_objetivo):
    subconjunto = CONJUNTO[np.array(individuo) == 1]
    suma_subconjunto = np.sum(subconjunto)
    diferencia = suma_objetivo - suma_subconjunto
    n_elementos = sum(individuo)
    if diferencia < 0: # nos pasamos
        return 10000, 10000 # pena de muerte    
    if n_elementos == 0: # no se selecciona ninguna elemento
        return 10000, 10000 # pena de muerte
    return n_elementos, diferencia

"""**Registro de operadores genéticos:**

1.   Cruce de dos puntos.
2.   Mutación bitflip.
3.   Selección mediante torneo, tamaño del torneo igual a 3 (suele ir bien para la mayoría de problemas). Si tenemos muchas variables podemos probar a aumentarlo un poco.
4.   Función de evaluación.
"""

toolbox.register("mate", tools.cxTwoPoint) 
toolbox.register("mutate", tools.mutFlipBit, indpb=0.05) 
toolbox.register("select", tools.selNSGA2) 
toolbox.register("evaluate", funcion_objetivo, suma_objetivo=SUMA_OBJETIVO)

"""Función para representar el **frente de Pareto**."""

def plot_frente(pareto):
    lista_fitness1 = list()
    lista_fitness2 = list()
    for ind in pareto: # recorremos los elementos del Pareto
        lista_fitness1.append(ind.fitness.values[0])
        lista_fitness2.append(ind.fitness.values[1])    
    plt.scatter(lista_fitness1, lista_fitness2, marker="+", color="b", s=50)    
    plt.xlabel("Elementos")
    plt.ylabel("Diferencias")
    plt.grid(True)
    plt.xlim([0, 17])
    plt.ylim([-20, 350])
    plt.legend(["Frente de Pareto"], loc="upper right")
    plt.savefig("Pareto_conjunto.eps", dpi = 300)

"""En el main configuramos el algoritmo genético. 

Ajuste de los operadores genéticos:
* *CXPB:* probabilidad de cruce
* *MUTPB:* probabilidad de mutación

Número de generaciones:
* *NGEN:* número de generaciones

El objeto **hof** almacena el mejor individuo encontrado a lo largo de las generaciones. Le tenemos que p

El objeto **stats** calcula las estadísticas de la población en cada generación. Cuando se define le tenemos que decir sobre qué se va a calcular las estadística. A continuación, se deben registrar las funciones estadísticas que se van a aplicar.

El objeto **logbook** almacena todas las estadísticas calculadas por generación en un solo objeto.

Algoritmo **eaMuPlusLambda** parámetros que tenemos que pasar:
* poblacion (obligatorio)
* toolbox (obligatorio)
* mu, número de inviduos de la población (obligatorio)
* lambda, número de individuos a seleccionar para pasar la siguiente generación. Si no queremos que la población cambie de tamaño mu=lamnda. (obligatorio)
* probabilidad de cruce (obligatorio)
* probabilidad de mutación (obligatorio)
* número de generaciones (obligatorio)
* objeto de estadísticas (opcional)
* objeto hallofFame que almacena el mejor individuo (opcional)
* Si queremos que se muestre las estádisticas en cada generación, verbose = True (opcional)
"""

def main():
    CXPB, MUTPB, NGEN = 0.7, 0.3, 200
    MU, LAMBDA = 300, 300
    pop = toolbox.population(MU)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("std", np.std)
    stats.register("min", np.min)
    stats.register("max", np.max)
    logbook = tools.Logbook()  
    pareto = tools.ParetoFront() 
    pop, logbook = algorithms.eaMuPlusLambda(pop , toolbox , mu=MU, lambda_=LAMBDA, cxpb=CXPB, mutpb=MUTPB, ngen=NGEN, stats=stats, halloffame=pareto,  verbose=True)
    return pop, logbook, pareto

"""Lanzamos el algoritmo y mostramos los resultados."""

if __name__ == "__main__":    
    pop, log, pareto = main()
    plot_frente(pareto)